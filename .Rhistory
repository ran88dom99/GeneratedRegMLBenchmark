rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{M<-out.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{M<-out.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
use.mean<-F
min.corr<-.90#only if use.mean is false
out.array<-array(0, c(length(u.learns), length(u.learns)))
out.array.mean<-array(0, c(length(u.learns), length(u.learns)))
#how often is each intersection true?
#for every model model
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{M<-out.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
library("profvis", lib.loc="~/R/win-library/3.3")
remove.packages("profvis", lib="~/R/win-library/3.3")
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Caret part.R')
sessionInfo()
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
out.array<-array(0, c(length(u.learns), length(u.learns)))
out.array.mean<-array(0, c(length(u.learns), length(u.learns)))
not.na.array<-array(0, c(length(u.learns), length(u.learns)))
#how often is each intersection true?
#for every model model
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
not.na.array[n,c]=not.na.array[n,c]+1
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{
M<-out.array/not.na.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
warnings()
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
library(earth)
earth.mod <- earth(Volume ~ ., data = trees)
plotmo(earth.mod)
summary(earth.mod, digits = 2, style = "pmax")
earth.mod
str(earth)
str(earth.mod)
trees
earth.mod$bx
str(fitted.values.earth
)
earth.mod$
fitted.values.earth()
fitted.values.earth()
fitted.values.earth
earth.mod$dirs
earth.mod$cuts
earth.mod$selected.terms
earth.mod$coefficients
earth.mod$terms
earth.mod$terms
earth.mod$termcond
earth.mod$prune.terms
earth.mod <- earth(ozone1[,c(1)], ozone1[,-c(1)])
earth.mod <- earth(O3 ~ ., data = ozone1)
data("ozone1")
earth.mod <- earth(O3 ~ ., data = ozone1)
plotmo(earth.mod)
plotmo(earth.mod)
summary(earth.mod, digits = 2, style = "pmax")
earth.mod <- earth(O3 ~ ., data = ozone1,degree = 3)
plotmo(earth.mod)
summary(earth.mod, digits = 2, style = "pmax")
earth.mod$bx
earth.mod$dirs
earth.mod$cuts
earth.mod$selected.terms
earth.mod$coefficients
summary(earth.mod, digits = 2, style = "pmax")
summary(earth.mod, digits = 2, style = "pmax")
earth.mod$bx
earth.mod$dirs
earth.mod$cuts
detach("package:earth", unload=TRUE)
library("earth", lib.loc="~/R/win-library/3.3")
library("Cubist", lib.loc="~/R/win-library/3.3")
library(Cubist)
library(mlbench)
data(BostonHousing)
BostonHousing$chas <- as.numeric(BostonHousing$chas) - 1
set.seed(1)
inTrain <- sample(1:nrow(BostonHousing), floor(.8*nrow(BostonHousing)))
trainingPredictors <- BostonHousing[ inTrain, -14]
testPredictors<- BostonHousing[-inTrain, -14]
trainingOutcome <- BostonHousing$medv[ inTrain]
testOutcome<- BostonHousing$medv[-inTrain]
modelTree <- cubist(x = trainingPredictors, y = trainingOutcome)
modelTree
dotplot(modelTree)
dotplot(modelTree,what = "splits")
dotplot(modelTree,what = "coefs")
install.packages("recommenderlab")
install.packages("recommenderlabBX")
install.packages("recommenderlabJester")
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
View(before.last.alg)
View(before.last.alg)
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Caret part.R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
try({trainedmodel <- train(x=data.frame(training[,2:length(training[1,])]),
y =  df.toprocess[inTrain,1],
method = allmodel)
predicted.outcomes<-predict(trainedmodel, newdata=(testing))
p <- data.frame(predicted.outcomes,testing)
#Rsqd =(1-sum((p[,2]-p[,1])^2, na.rm = T)/sum((p[,2]-mean(p[,2]))^2, na.rm = T))
Rsqd=1-RMSE(p[,1],p[,2])/RMSE(p[,2],mean(p[,2], na.rm = T))
#mean.improvement=1-mean(abs(p[,2]-p[,1]), na.rm = T)/mean(abs(p[,2]-median(p[,2])), na.rm = T)
mean.improvement=1-MAE(p[,1],p[,2])/MAE(p[,2],mean(p[,2], na.rm = T))
p<- data.frame(predict(loess.model,predicted.outcomes),y.untransformed[-inTrain])
#RMSE=(sqrt(mean((p[,1]-p[,2])^2, na.rm = T)))
RMSE=RMSE(p[,1],p[,2])
#RMSE.mean=(sqrt(mean((p[,2]-mean(p[,2]))^2, na.rm = T)))
RMSE.mean=RMSE(p[,2],mean(p[,2], na.rm = T))
#MMAAEE=mean(abs(p[,2]-p[,1]), na.rm = T)
MMAAEE=MAE(p[,1],p[,2])
overRMSE=-1
try({wut=print(trainedmodel,selectCol=TRUE)
overRMSE=as.numeric(wut[wut[,length(wut[1,])]=="*","RMSE"])})#length(wut[1,])-
replace.overRMSE=1
try({if(is.numeric(overRMSE)){replace.overRMSE=0}})
if(replace.overRMSE==1){overRMSE=-1}
if(length(overRMSE)<1){overRMSE=-1}
#print(c(Rsqd,RMSE,overRMSE,date(),allmodel,column.to.predict,datasource,missingdata,withextra,norming,adaptControl$search,seed.const,adaptControl$method,tuneLength,adaptControl$number,adaptControl$repeats,adaptControl$adaptive$min,trainedmodel$bestTune))
write.table(c(round(mean.improvement,digits = 3),round(Rsqd,digits = 3),round(overRMSE,digits = 3),
round(RMSE,digits = 3),round(MMAAEE,digits = 3),date(),allmodel,column.to.predict,
trans.y,datasource,missingdata,withextra,norming,RMSE.mean,simpleControl$search,
seed.var,round(proc.time()[3]-when[3]),"nohyperparameters",tuneLength2,
simpleControl$number,"no rep","no min",trainedmodel$bestTune),
file = "gen test out.csv", append =TRUE, quote = F, sep = ",",
eol = "\n", na = "NA", dec = ".", row.names = F,
col.names = F, qmethod = "double")
print(date())
not.failed=1
})
library(caret)
library(caret)
library(MLmetrics)
library(caret)
library(MLmetrics)
if(rnorm(1, mean = 0, sd = 1)>1.5)
{}
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
{}
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
(rnorm(1, mean = 0, sd = 1)>1.5)
for(Row in 1:Rows){
simScores[Row,1:10]=rnorm(10, mean = 0, sd = 1)
}
for(Row in 1:Rows){
if(rnorm(1, mean = 0, sd = 1)>1.5){###error used to be posssible to switch
simScores[Row,1]=rnorm(1, mean = 0, sd = 7)
}else{
simScores[Row,1]=simScores[Row,2]
}
}
Rows=100
for(Row in 1:Rows){
simScores[Row,1:10]=rnorm(10, mean = 0, sd = 1)
}
for(Row in 1:Rows){
if(rnorm(1, mean = 0, sd = 1)>1.5){###error used to be posssible to switch
simScores[Row,1]=rnorm(1, mean = 0, sd = 7)
}else{
simScores[Row,1]=simScores[Row,2]
}
}
simScores<-matrix
for(Row in 1:Rows){
simScores[Row,1:10]=rnorm(10, mean = 0, sd = 1)
}
for(Row in 1:Rows){
if(rnorm(1, mean = 0, sd = 1)>1.5){###error used to be posssible to switch
simScores[Row,1]=rnorm(1, mean = 0, sd = 7)
}else{
simScores[Row,1]=simScores[Row,2]
}
}
simScores<-matrix()
for(Row in 1:Rows){
simScores[Row,1:10]=rnorm(10, mean = 0, sd = 1)
}
for(Row in 1:Rows){
if(rnorm(1, mean = 0, sd = 1)>1.5){###error used to be posssible to switch
simScores[Row,1]=rnorm(1, mean = 0, sd = 7)
}else{
simScores[Row,1]=simScores[Row,2]
}
}
simScores<-matrix(nrow=100,ncol = 10)
for(Row in 1:Rows){
simScores[Row,1:10]=rnorm(10, mean = 0, sd = 1)
}
for(Row in 1:Rows){
if(rnorm(1, mean = 0, sd = 1)>1.5){###error used to be posssible to switch
simScores[Row,1]=rnorm(1, mean = 0, sd = 7)
}else{
simScores[Row,1]=simScores[Row,2]
}
}
Rows=100
for(Row in 1:Rows){
simScores[Row,1:10]=rnorm(10, mean = 0, sd = 1)
}
for(Row in 1:Rows){
if(rnorm(1, mean = 0, sd = 1)>1.5){###error used to be posssible to switch
simScores[Row,1]=rnorm(1, mean = 0, sd = 7)
}else{
simScores[Row,1]=simScores[Row,2]
}
}
View(simScores)
hold<-abs(simScores[,1]-simScores[,2])
hold
hold^2
mean(hold)
meannn<-abs(simScores[,1]-mean(simScores[,2]))
meannn
mean(hold)
mean(meannn)
1-mean(hold)/mean(meannn)
sum(hold^2)
sum(meannn^2)
1-236/387
mean(hold)
mean(hold)^2
1-(mean(hold)^2)/(mean(meannn)^2)
mean(meannn)^2
install.packages("darch")
Var1 <- c(rep(1, 50), rep(0, 50))
Var2 <- c(rep(0, 50), rep(1, 50))
x3 <- matrix(c(Var1, Var2), nrow = 100, ncol = 2)
r1 <- rbm.train(x3, 10, numepochs = 20, cd = 10)
library(darch)
library(deepnet)
r1 <- rbm.train(x3, 10, numepochs = 20, cd = 10)
Var1
Var2
nn.predict(r1,c(1,1,1) )
h <- c(0.2, 0.8, 0.1)
v <- rbm.down(r1, h)
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
View(v)
Var1 <- c(rep(1, 50), rep(0, 50))
Var2 <- c(rep(0, 50), rep(1, 50))
x3 <- matrix(c(Var1, Var2), nrow = 100, ncol = 2)
r1 <- rbm.train(x3, 3, numepochs = 20, cd = 10)
v <- c(0.2, 0.8)
h <- rbm.up(r1, v)
View(h)
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
View(h2)
View(v2)
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
View(h2)
View(v2)
source('C:/Users/Dm/Desktop/generated data test/boltzman machines.R')
trainRBM(rbm, x3)
library(darch)
library(deepnet)
trainRBM(rbm, x3)
trainRBM(rbm, x3)
data(iris)
model <- darch(Species ~ ., iris)
print(model)
predictions <- predict(model, newdata = iris, type = "class")
cat(paste("Incorrect classifications:", sum(predictions != iris[,5])))
trainData <- matrix(c(0,0,0,1,1,0,1,1), ncol = 2, byrow = TRUE)
trainTargets <- matrix(c(0,1,1,0), nrow = 4)
model2 <- darch(trainData, trainTargets, layers = c(2, 10, 1),
darch.numEpochs = 500, darch.stopClassErr = 0, retainData = T)
e <- darchTest(model2)
cat(paste0("Incorrect classifications on all examples: ", e[3], " (",
e[2], "%)\n"))
plot(model2)
trainData
trainTargets
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
