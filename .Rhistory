(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
corrplot(M.AOE)
data(mtcars)
M <- cor(mtcars)
##  different color series
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
wb <- c("white","black")
corrplot(M, method = "number", col = "black", cl.pos = "n")
corrplot(M, method = "number")
corrplot(M)
corrplot(M, order = "AOE")
corrplot(M, order = "AOE", addCoef.col = "grey")
corrplot(M, order = "AOE", addCoef.col = "black")
corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(10), addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(10), addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col2(200))
corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col2(200))
corrplot(M, order = "AOE", col = col2(200), addCoef.col = "grey")
corrplot(M, order = "AOE", col = col2(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col2(10), addCoef.col = "grey")
corrplot(M, order = "AOE", col = col3(100))
corrplot(M, order = "AOE", col = col3(10))
corrplot(M, method="color", col=col1(20), cl.length=21,order = "AOE", addCoef.col="grey")
corrplot(M, method="square", col=col2(200),order = "AOE")
corrplot(M, method="ellipse", col=col1(200),order = "AOE")
corrplot(M, method="shade", col=col3(20),order = "AOE")
corrplot(M, method="pie", order = "AOE")
corrplot(M, order = "AOE", col = col3(100))
corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(10), addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, method="color", col=col1(20), cl.length=21,order = "AOE", addCoef.col="grey")
corrplot(M, col = wb, order="AOE", outline=TRUE, cl.pos="n")
corrplot(M, col = wb, bg="gold2",  order="AOE", cl.pos="n")
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="ell",order="AOE",
diag=FALSE,tl.pos="n", cl.pos="n")
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="square",order="AOE",
diag=FALSE,tl.pos="n", cl.pos="n")
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="number",order="AOE",
diag=FALSE,tl.pos="n", cl.pos="n")
corrplot(M,order="AOE",type="upper",tl.pos="tp")
corrplot(M,add=TRUE, type="lower", method="number",order="AOE", col="black",
diag=FALSE,tl.pos="n", cl.pos="n")
corrplot(M, order="hclust")
corrplot(M, order="hclust", addrect = 2)
corrplot(M, order="hclust", addrect = 2)
corrplot(M, order="hclust", addrect = 3, rect.col = "red")
corrplot(M, order="hclust", addrect = 4, rect.col = "blue")
corrplot(M, order="hclust", hclust.method="ward", addrect = 4)
(order.AOE <- corrMatOrder(M, order = "AOE", addrect = 4))
(order.AOE <- corrMatOrder(M, addrect = 4, order = "AOE"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2",addrect = 4))
(order.hc <- corrMatOrder(M, order = "hclust",addrect = 4))
(order.hc <- corrMatOrder(M, order = "hclust",addrect = 2))
corrplot(M, order="hclust", addrect = 2)
corrplot(abs(M),order="AOE", cl.lim=c(0,1))
corrplot(abs(M),order="AOE", col=col1(20), cl.lim=c(0,1))
corrplot(abs(M),order="AOE", col=col3(200), cl.lim=c(0,1))
ran <- round(matrix(runif(225, -100,100), 15))
corrplot(ran, is.corr=FALSE)
(order.AOE <- corrMatOrder(M,  order = "AOE", is.corr=FALSE))
corrplot(M.AOE, is.corr=FALSE)
corrplot(M.AOE, is.corr=FALSE,addrect = 2)
corrplot(M, col = wb, order="AOE", outline=TRUE, cl.pos="n")
corrplot(M, method="ellipse", col=col1(200),order = "AOE")
corrplot(M.FPC, method="ellipse", col=col1(200))
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200))
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
t
corrplot(M, order="AOE", type="lower", cl.pos="b", diag=FALSE)
corrplot(M, order="AOE", tl.srt=45)
corrplot(M, order="AOE", tl.srt=60)
corrplot(M, order="AOE", tl.pos="d",cl.pos="n")
corrplot(M, order="AOE", diag=FALSE, tl.pos="d")
corrplot(M, order="AOE", type="upper")
corrplot(M, order="AOE", type="upper", diag=FALSE)
corrplot(M, order="AOE", type="lower", cl.pos="b")
corrplot(M, order="AOE", tl.pos="d",cl.pos="n")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="l")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="c")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="r")
corrplot(M, order="AOE", cl.pos="b")
corrplot(M, order="AOE", cl.pos="b", tl.pos="d")
corrplot(M, order="AOE", cl.pos="n")
M2 <- M
diag(M2) = NA
corrplot(M2)
corrplot(M2, na.label = "o")
corrplot(M2, na.label = "NA")
corrplot(M[1:8,])
corrplot(M[,1:8])
cor.mtest <- function(mat, conf.level = 0.95){
mat <- as.matrix(mat)
n <- ncol(mat)
p.mat <- lowCI.mat <- uppCI.mat <- matrix(NA, n, n)
diag(p.mat) <- 0
diag(lowCI.mat) <- diag(uppCI.mat) <- 1
for(i in 1:(n-1)){
for(j in (i+1):n){
tmp <- cor.test(mat[,i], mat[,j], conf.level = conf.level)
p.mat[i,j] <- p.mat[j,i] <- tmp$p.value
lowCI.mat[i,j] <- lowCI.mat[j,i] <- tmp$conf.int[1]
uppCI.mat[i,j] <- uppCI.mat[j,i] <- tmp$conf.int[2]
}
}
return(list(p.mat, lowCI.mat, uppCI.mat))
}
res1 <- cor.mtest(mtcars,0.95)
res2 <- cor.mtest(mtcars,0.99)
corrplot(M, p.mat = res1[[1]], sig.level=0.2)
corrplot(M, p.mat = res1[[1]], sig.level=0.05)
corrplot(M, p.mat = res1[[1]], sig.level=0.01)
corrplot(M, p.mat = res1[[1]], insig = "blank")
corrplot(M, p.mat = res1[[1]], insig = "p-value")
corrplot(M, p.mat = res1[[1]], insig = "p-value", sig.level=-1) ## add all p-values
corrplot(M, p.mat = res1[[1]], order="hclust", insig = "blank", addrect=3)
corrplot(M, p.mat = res1[[1]], order="hclust", insig = "pch", addrect=3)
corrplot(M,low=res1[[2]], upp=res1[[3]],
plotC="circle", addg="grey20",cl.pos="n")
corrplot(M, p.mat = res1[[1]],low=res1[[2]], upp=res1[[3]],
plotC="circle", addg="grey20",cl.pos="n")
corrplot(M, low=res1[[2]], upp=res1[[3]],
col=c("white","black"),bg="gold2",order="AOE",
plotCI="circle",cl.pos="n",pch.col="red")
corrplot(M, p.mat = res1[[1]], low=res1[[2]], upp=res1[[3]],
col=c("white","black"),bg="gold2",order="AOE",
plotCI="circle",cl.pos="n",pch.col="red")
corrplot(M, low=res1[[2]], upp=res1[[3]],
col=c("white","black"),bg="gold2", order="AOE",
plotCI="square",addg=NULL,cl.pos="n")
corrplot(M, p.mat = res1[[1]],low=res1[[2]], upp=res1[[3]],
col=c("white","black"),bg="gold2",order="AOE",pch.col="red",
plotC="square", addg=NULL,cl.pos="n")
corrplot(M, low=res1[[2]], upp=res1[[3]], order="hclust",
rect.col="navy", plotC="rect",cl.pos="n")
corrplot(M, p.mat = res1[[1]], low=res1[[2]], upp=res1[[3]], order="hclust",
pch.col="red", sig.level = 0.05, addrect=3, rect.col="navy",
plotC="rect",cl.pos="n")
corrplot(M, p.mat = res2[[1]], low=res2[[2]], upp=res2[[3]], order="hclust",
pch.col="red", sig.level = 0.01, addrect=3, rect.col="navy",
plotC="rect",cl.pos="n")
par(ask=FALSE)
for(i in seq(0.1, 0, -0.005)){
tmp <- cor.mtest(mtcars,1-i)
corrplot(M, p.mat = tmp[[1]], low=tmp[[2]], upp=tmp[[3]], order="hclust",
pch.col="red", sig.level = i, plotC="rect", cl.pos="n",
mar=c(0,0,1,0),
title=substitute(alpha == x,list(x=format(i,digits=3,nsmall=3))))
Sys.sleep(0.15)
}
for(i in seq(0.1, 0, -0.005)){
tmp <- cor.mtest(mtcars,1-i)
corrplot(M, p.mat = tmp[[1]], low=tmp[[2]], upp=tmp[[3]], order="hclust",
pch.col="red", sig.level = i, plotC="rect", cl.pos="n",
mar=c(0,0,1,0),
title=substitute(alpha == x,list(x=format(i,digits=3,nsmall=3))))
Sys.sleep(0.15)
}
corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black"))
corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
M<-out.array
corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
if(F){
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
#if(pearson.array[n,c,g]>=min.corr)
#  {out.array[n,c]=out.array[n,c]+1}
}
}}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
M<-out.array
library('corrplot') #package corrplot
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
?cor
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
#make 140x140DF p.a.1
out.array<-array(0, c(length(u.learns), length(u.learns)))
out.array.mean<-array(-1.1, c(length(u.learns), length(u.learns)))
#how often is each intersection true?
min.corr<-.96
#for every model model
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
outr.array<-out.array/max(out.array)
corrplot(outr.array, method = "circle")
#stickyball selfsticing map
corrplot(out.array, method = "circle")
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
M<-out.array
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
M<-out.array.mean
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
last.count
sum.of.cors
cor(as.numeric(sssVIR[g,]),as.numeric(selselVIR[n,]),method ="spearman")
n
g
as.numeric(sssVIR[g,])
sssVIR[g,]
selselVIR[n,]
debugSource('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
ev2.learn
ev2.learn
ev.learn
sssVIR
sssVIR
selselVIR
debugSource('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
debugSource('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
ran(1,3,2,2,2)
rank(1,3,2,2,2)
rank(c(1,3,2,2,2))
rank.inters<-rank(every.intersection)
Lselsel
Lsss
every.intersection<-vector(mode = "numeric", length = Lselsel * Lsss)
for(n in 1:Lselsel){
for(g in 1:Lsss){
every.intersection[g+Lsss*(n-1)]<-cor(as.numeric(sssVIR[g,]),as.numeric(selselVIR[n,]),method ="spearman")
}
}
rank.inters<-rank(every.intersection)
every.intersection
sssVIR[g,]
g
n
selselVIR[n,]
selselVIR
Lselsel
VarImpResults[selVIRL,1]
ev.learn
rank.inters<-rank(every.intersection)
min.accept<-Lselsel * Lsss-min(Lselsel,Lsss)
min.accept
Lselsel * Lsss
min(Lselsel,Lsss)
min.accept
rank.inters>min.accept
mean(every.intersection[rank.inters>min.accept],na.rm = T)
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
S.pear<-"spearman"#"pearson","kendall"
use.mean<-F
min.corr<-.94#only if use.mean is false
corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#make 140x140DF p.a.1
out.array<-array(0, c(length(u.learns), length(u.learns)))
out.array.mean<-array(0, c(length(u.learns), length(u.learns)))
#how often is each intersection true?
#for every model model
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{M<-out.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{M<-out.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
use.mean<-F
min.corr<-.90#only if use.mean is false
out.array<-array(0, c(length(u.learns), length(u.learns)))
out.array.mean<-array(0, c(length(u.learns), length(u.learns)))
#how often is each intersection true?
#for every model model
for(n in 1:length(u.learns)){
for(c in 1:length(u.learns)){
out.array.mean[n,c]=mean(pearson.array[n,c,], na.rm = T)
#for every generator
for(g in 1:length(u.gens)){
#sum Ts into 140xxdf
if(!is.na(pearson.array[n,c,g])){
if(pearson.array[n,c,g]>=min.corr)
{out.array[n,c]=out.array[n,c]+1}
}
}}}
colnames(out.array) <- u.learns
rownames(out.array) <- u.learns
colnames(out.array.mean) <- u.learns
rownames(out.array.mean) <- u.learns
#outr.array<-out.array/max(out.array)
#corrplot(out.array, method = "circle")
#stickyball selfsticing map
#clustering in other words
#############corrmat##########
if(T){
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
"cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
"#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
"cyan", "#007FFF", "blue","#00007F"))
if(use.mean){
M<-out.array.mean}else{M<-out.array}
library('corrplot') #package corrplot
#corrplot(M, method = "circle") #plot matrix
M[is.na(M)]<-0
(order.AOE <- corrMatOrder(M,  order = "AOE"))
(order.FPC <- corrMatOrder(M, order = "FPC"))
(order.hc <- corrMatOrder(M, order = "hclust"))
(order.hc2 <- corrMatOrder(M, order = "hclust", hclust.method = "ward.D2"))
M.AOE <- M[order.AOE,order.AOE]
M.FPC <- M[order.FPC,order.FPC]
M.hc  <- M[order.hc, order.hc]
M.hc2 <- M[order.hc2,order.hc2]
par(ask = F)
#corrplot(M)
#corrplot(M.AOE, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
corrplot(M.FPC, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
#corrplot(M.hc2, is.corr=FALSE,addrect = 2, method="ellipse", col=col1(200), addCoef.col = "black")
}
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
library("profvis", lib.loc="~/R/win-library/3.3")
remove.packages("profvis", lib="~/R/win-library/3.3")
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Caret part.R')
sessionInfo()
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Var Imp Fil cluster.R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
source('C:/Users/Dm/Desktop/generated data test/Model Tester Quick .R')
